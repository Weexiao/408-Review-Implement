# 动态规划

## 三大步骤

动态规划即利用历史记录，避免重复计算，这些历史记录一般需要一些变量来存储，一般使用一维数组或二维数组，动态规划主要有三大步

1. **定义数组元素的含义**，即会使用一个数组，来保存历史数组，假设是一维数组dp[]，这时十分重要的问题就是这个dp[i]到底是什么意思
2. **找出数组元素之间的关系式**，类似于归纳法，即计算dp[n]时，可以利用dp[n-1]、dp[n-2]、……、dp[1]来推出dp[n]，所以我们需要使用历史数据来推出新的元素值，一般来说这不时最难的
3. **找出初始值**，如dp[n]=dp[n-1]+dp[n-2]，则我们必须需要获得dp[2]和dp[1]的值，这就是初始值

## 案例

### 简单的一维DP

> 问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

1. 定义数组元素的含义：设dp[i]为跳上i级台阶总共有几种跳法
2. 找出数组元素的关系式：可见跳上n级台阶可以从n-1跳上来或者n-2跳上来，故dp[n]=dp[n-1]+dp[n-2]
3. 找出初始值：可见初始值为dp[0]=0，dp[1]=1

算法如下：

```c
/*
    简单的一维DP：
    问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法
*/
int f1(int n)
{
    int dp[n+1];
    dp[0]=0, dp[1]=1;
    for(int i=2; i<=n; i++)
        dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
}
```

但该算法是有问题的，即dp[2]应等于2，但上述结果为1，这就需要优化初始值，可见需要对初始值进行修改，将dp[2]=2也加进去

### 二维数组的DP

> ##### 问题描述
>
> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 问总共有多少条不同的路径？
>
> ![img](%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/e100d52a194e5c188987f64427d2eba7.png)

1. 定义数组元素的含义：dp\[i][j]为到(i, j)处可能的路径个数，故dp\[m-1][n-1]就为所求值
2. 找出数组元素的关系式：易得dp\[i][j] = dp\[i][j-1] + dp\[i-1][j]
3. 找出初始值：可得i，j值都不能为0，故需要求出所有的dp[0]\[]和dp\[][0]，易得该值都为1

算法如下：

```c
/*
问题描述
    一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
    机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
    问总共有多少条不同的路径？
*/
int f2(int m, int n)
{
    if(m <= 0 || n <= 0)
        return 0;

    int dp[m][n];
    for(int i = 0; i < n; i++)
        dp[0][i] = 1;
    for(int i = 0; i < m; i++)
        dp[i][0] = 1;
    for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
    
    return dp[m-1][n-1];
}
```

> ##### 问题描述
>
> 给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> **说明：**每次只能向下或者向右移动一步。
>
> ```javascript
> 举例：
> 输入:
> arr = [
>   [1,3,1],
>   [1,5,1],
>   [4,2,1]
> ]
> 输出: 7
> 解释: 因为路径 1→3→1→1→1 的总和最小。
> ```

本质上是最优路径和

1. 定义数组元素的含义：dp\[i][j]为到达当前点的最小路径和
2. 找出数组元素的关系：dp\[i][j] = min(dp\[i-1][j] , dp\[i][j-1] + arr\[i][j])
3. 找出初始值：易得i，j不为1，故dp\[0][i] = dp\[0][i-1] + arr\[0][i]; dp\[i][0] = dp\[i-1][0] + arr\[i][0]

```c
int m = gridSize;
    int n = gridColSize[0];

    if(m <= 0 || n <= 0)
        return 0;

    int dp[m][n];
    dp[0][0] = grid[0][0];
    for(int i=1; i<n; i++)
        dp[0][i] = dp[0][i-1] + grid[0][i];
    for(int i=1; i<m; i++)
        dp[i][0] = dp[i-1][0] + grid[i][0];

    for (int i = 1; i < m; i++)
        for (int j = 1; j < n; j++)
            dp[i][j] = min(dp[i-1][j]+grid[i][j], dp[i][j-1]+grid[i][j]);
    
    return dp[m-1][n-1];
```

> **问题描述**
>
> 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。
>
> 你可以对一个单词进行如下三种操作：
>
> - 删除一个字符
> - 替换一个字符
> - 插入一个字符
>
> ```javascript
> 示例 1:
> 输入: word1 = "horse", word2 = "ros"
> 输出: 3
> 解释: 
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')
> ```

1. 定义数组元素的含义：dp[i] [j]的含义为：**当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]**

2. 找出数组元素的关系：

	由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：

	一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。（别忘了 dp[i] [j] 的含义哈）。

	二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：

	（1）、如果把字符 word1[i] 替换成与 word2[j] 相等即往左上走，则有 dp[i] [j] = dp[i-1] [j-1] + 1;

	（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符即往左走，则有 dp[i] [j] = dp[i] [j-1] + 1;

	（3）、如果把字符 word1[i] 删除一个字符即往上走，则有 dp[i] [j] = dp[i-1] [j] + 1;

	那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有

	**dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;**

3. 找出初始值：i，j不能为零，dp\[0][0] = 0, dp\[0][i] = dp\[0][i-1]+1; dp\[i][0] = dp\[i-1][0]+1

```c
int f4(char * word1, char * word2)
{
    int m = strlen(word1), n = strlen(word2);

    if(n*m == 0)
        return n+m;

    int dp[m+1][n+1];
    dp[0][0] = 0;
    for(int i = 1; i < m+1; i++)
        dp[i][0] = dp[i-1][0] + 1;
    for(int j = 1; j < n+1; j++)
        dp[0][j] = dp[0][j-1] + 1;

    for(int i = 1; i < m+1; i++)
    {
        for (int j = 1; j < n+1; j++)
        {
            if (word1[i-1] == word2[j-1])
                dp[i][j] = dp[i-1][j-1];
            else
                dp[i][j] = min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1])) + 1;
        }
    }

    return dp[m][n];
}
```

